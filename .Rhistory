else {if (j<21){
b.matrix[,j]=sample(c(runif(3,1,2),runif(3,5,6),runif(4,9,10)),K)
}
else {
b.matrix[,j]=sample(c(runif(3,-2,-1),runif(3,-6,-5),runif(4,-10,-9)),K)
}
}
}
modified.b.matrix<-matrix(0,ncol=60,nrow=K)
for (j in 1:30){
modified.b.matrix[,(j*2-1)]=b.matrix[,j]
}
}
}
if (Pred_type=="Con"){
while (t<K){
n.temp=sample(seq(nlower,nupper),1)
n=c(n,n.temp)
sid.temp=rep(t+1,n.temp)
sid=c(sid,sid.temp)
# temp.x=mvrnorm(n.temp,mu=rep(0,J),Sigma=Sigma)
temp.x=mvrnorm(n.temp,mu=runif(J,-100,100),Sigma=diag(runif(J,-5,5))%*%Sigma%*%runif(J,-5,5)))
temp.rb=c(fixed.b[1:5],rep(0,100),fixed.b[6:10],rep(0,100),modified.b.matrix[(t+1),])
temp.y=rnorm(1,0,5)+temp.x[,1:270]%*%temp.rb+rnorm(n.temp,0,sigma)
temp.y=temp.y
# temp.x=scale(temp.x)
x=rbind(x,temp.x)
y=c(y,temp.y)
t=t+1
}} else {
# allele.freq=runif(J,0.05,0.5)
while (t<K){
allele.freq=runif(J,0.05,0.5)
n.temp=sample(seq(nlower,nupper),1)
n=c(n,n.temp)
sid.temp=rep(t+1,n.temp)
sid=c(sid,sid.temp)
divider=rep(0,J)
temp.x1=matrix(0,ncol=J,nrow=n.temp)
temp.x2=matrix(0,ncol=J,nrow=n.temp)
temp.z1=mvrnorm(n.temp,mu=rep(0,J),Sigma=Sigma)
temp.z2=mvrnorm(n.temp,mu=rep(0,J),Sigma=Sigma)
for (j in 1:J){
temp.x1[,j]=ifelse(temp.z1[,j]<=qnorm(allele.freq[j]),1,0)
temp.x2[,j]=ifelse(temp.z2[,j]<=qnorm(allele.freq[j]),1,0)
divider[j]=sqrt(allele.freq[j]*(1-allele.freq[j]))
}
temp.x=temp.x1+temp.x2
temp.rb=c(fixed.b[1:5],rep(0,100),fixed.b[6:10],rep(0,100),modified.b.matrix[(t+1),])# /divider[1:270]
temp.y=rnorm(1,0,5)+temp.x[,1:270]%*%temp.rb+rnorm(n.temp,0,sigma)
# temp.x=scale(temp.x)
temp.x[is.na(temp.x)]<-0
x=rbind(x,temp.x)
y=c(y,temp.y)
t=t+1
}
}
x=x[-1,]
y=y[-1]
n=n[-1]
sid=sid[-1]
return(list(x,y,n,sid))
}
group_lasso<-function(x,y,sid,wt,solution_path=FALSE,y_name=NULL){
##### sorting data by study
library(tidyverse)
data=as.data.frame(cbind(sid,y,x))
data=arrange(data,sid)
n=as.data.frame(table(sid))[,2]
x=as.matrix(data[,-c(1:2)])
y=data$y
sid=data$sid
J=ncol(x)
K=length(unique(sid))
lambda=c(0,0)
lambda[1]=ifelse(sum(n)>J,0.0001,0.01)
lambda[2]=ifelse(sum(n)>(J*K),0.001,0.05)
#### finding lasso estimates for beta j by bic
####### weighting
weight=0
for (k in 1:K){
temp=1/c(rep(sqrt(n[k]),n[k]))
weight=c(weight,temp)
}
weight=weight[-1]
if (wt==TRUE){
w.x=x*weight
w.y=y*weight
} else {
w.x=x
w.y=y
}
w.x=scale(w.x)
#### fitting adaptive LASSO with BIC
library(glmnet)
library(HDeconometrics)
ini.beta<-cv.glmnet(as.matrix(w.x),w.y,alpha=0,standardize=FALSE)
beta.bic.fit<-ic.glmnet(as.matrix(w.x),w.y,alpha=1,crit="bic",penalty.factor=1/abs(coef(ini.beta,s="lambda.min")[-1]),standardize=FALSE,lambda.min.ratio = lambda[1])
non.zero.beta=which(beta.bic.fit$coefficients[-1]!=0)
zero.beta=which(beta.bic.fit$coefficients[-1]==0)
#### finding OLS estimates for beta j
data=as.data.frame(cbind(y,x[,non.zero.beta]))
beta.ls.fit<-lm(y~.,data=data)
y.res=y-cbind(rep(1,length(y)),x[,non.zero.beta])%*%beta.ls.fit$coefficients
### step 1 estimates
step1_estimates=beta.bic.fit$coefficients[-1]
step1_estimates[non.zero.beta]=beta.ls.fit$coefficients[-1]
##### creating joint data set
x.by.var<-matrix(0,nrow=sum(n),ncol=J*K)
for (j in 1:J){
for (i in 1:K){
temp=x.by.var[,((j-1)*K+1):(j*K)]
if(i<2){
temp[1:n[i],i]=x[1:n[i],j]
}
else
temp[(sum(n[seq(1:(i-1))])+1):(sum(n[seq(1:(i))])),i]=x[(sum(n[seq(1:(i-1))])+1):(sum(n[seq(1:(i))])),j]
x.by.var[,((j-1)*K+1):(j*K)]=temp
}
}
x.by.var=scale(x.by.var)
##### fitting group lasso
library(gglasso)
group=rep(0,J*K)
for (j in 1:J){
group[((j-1)*K+1):(j*K)]=rep(j,K)
}
#### obtaining preliminary fit for delta j
ini.delta.cv.fit<-cv.glmnet(as.matrix(x.by.var),y.res,alpha=0,standardize=FALSE,intercept=TRUE)
ini.delta.fit<-glmnet(as.matrix(x.by.var),y.res,alpha=0,standardize=FALSE,intercept=TRUE,
lambda=ini.delta.cv.fit$lambda.min)
ini.delta.norm=rep(0,J)
ini.delta=ini.delta.fit$beta
for (j in 1:J){
ini.delta.norm[j]=norm(ini.delta[((j-1)*K+1):(j*K)],type="2")
}
#### fitting with all delta-j
ebic.grp.fit<-gglasso (as.matrix(x.by.var), y.res, group = group,
loss = "ls",
nlambda = 100,
lambda.factor = lambda[2],
pf = rep(sqrt(K),J)/(ini.delta.norm+0.000000000001),
dfmax = 1400,
pmax = 1400,
eps = 1e-08, maxit = 3e+08, intercept=TRUE)
####creating separate dataset
data.by.study<-list()
data.by.study[[1]]=cbind(y.res[1:(n[1])],x[1:(n[1]),])
for (k in 2:K){
data.by.study[[k]]=cbind(y.res[(sum(n[1:(k-1)])+1):sum(n[1:k])],x[(sum(n[1:(k-1)])+1):sum(n[1:k]),])
}
third.term.grp<-function(x,J,K,gamma){
num.p=length(x)/K
if (num.p==0){
factorial.part=0
}
else
factorial.part=sum(log(seq(1:J)))-(sum(log(seq(1:num.p)))+sum(log(seq(1:(J-num.p)))))
third.term=2*gamma*factorial.part
return(third.term)
}
index=abs(ebic.grp.fit$beta)>0
L=which.max(which(ebic.grp.fit$df<((n[which.min(n)]*2/3)*K)))
ebic=rep(0,L)
for (l in 1:length(ebic)){
temp.select_index=unique(group[index[,l]])
temp.fit=as.data.frame(cbind(as.factor(group),(ebic.grp.fit$beta)[,l]))
temp.selection=temp.fit[temp.fit$V1%in%temp.select_index,2]
temp.third=third.term.grp(temp.selection,J,K,1)
temp.ls.fit.lik=rep(0,K)
if (l<2){
for (k in 1:K){
temp.data=as.data.frame((data.by.study[[k]])[,1])
names(temp.data)=c("V1")
temp.ls.fit=lm(V1~.,data=temp.data)
temp.ls.fit.lik[k]=logLik(temp.ls.fit)
}
}else
{
temp.ls.coef=matrix(0,nrow=K,ncol=length(temp.select_index))
for (k in 1:K){
temp.data=as.data.frame(cbind((data.by.study[[k]])[,1],((data.by.study[[k]])[,-1])[,temp.select_index]))
temp.ls.fit=lm(V1~.,data=temp.data)
temp.ls.fit.lik[k]=logLik(temp.ls.fit)
temp.ls.coef[k,]=temp.ls.fit$coefficients[-1]
}
}
temp.dev=-2*(sum(temp.ls.fit.lik))
norm.lasso=rep(0,length(temp.selection)/K)
norm.ls=rep(0,length(temp.selection)/K)
if (length(temp.selection)/K>0){
for (i in 1:(length(temp.selection)/K)){
norm.lasso[i]=norm(temp.selection[((i-1)*K+1):(i*K)],type="2")
temp.ls.coef[is.na(temp.ls.coef[,i]),i]=0### replace NA by 0, ls fit model saturation
norm.ls[i]=norm(temp.ls.coef[,i],type="2")
}
temp.df=length(temp.selection)/K+(K-1)*sum(norm.lasso/norm.ls)
}else
{temp.df=0}
ebic[l]=temp.dev+temp.df*log(length(y.res))+temp.third
}
ebic.lambda=ebic.grp.fit$lambda[which.min(ebic)]
ebic.coef=ebic.grp.fit$beta[,which.min(ebic)]
ebic.fitted.delta=as.data.frame(cbind(as.factor(group),ebic.coef))
ebic.selection=ebic.fitted.delta%>%group_by(V1)%>%summarise_all(var)### sd not working
#### assessing performance
consistent=intersect(non.zero.beta,which(ebic.selection[,2]==0))
inconsistent=which(ebic.selection[,2]!=0)
noise=intersect(zero.beta,which(ebic.selection[,2]==0))
#### estimates
if (length(consistent)>0){
consistent_estimates=matrix(0,ncol=(K+1),nrow=length(consistent))
for (r in 1:length(consistent)){
consistent_estimates[r,]=c(consistent[r],rep(step1_estimates[consistent[r]],K))
}
consistent_estimates=as.matrix(consistent_estimates)
} else {
consistent_estimates=NULL
}
if (length(inconsistent)>0){
inconsistent_estimates=matrix(0,ncol=(K+1),nrow=length(inconsistent))
for (p in 1:length(inconsistent)){
inconsistent_estimates[p,]=c(inconsistent[p],ebic.fitted.delta[ebic.fitted.delta$V1==inconsistent[p],2]+step1_estimates[inconsistent[p]])
}
inconsistent_estimates=as.matrix(inconsistent_estimates)
} else {
inconsistent_estimates=NULL
}
#### outputting solution path
if (solution_path==TRUE){
plot(beta.bic.fit$glmnet,xvar = "lambda",main=paste(y_name,"step1",sep = " "))
abline(v=log(beta.bic.fit$lambda))
plot(ebic.grp.fit,main=paste(y_name,"step2",sep = " "))
abline(v =log(ebic.lambda))
}
return(list(consistent,inconsistent,noise,consistent_estimates,inconsistent_estimates))
}
eval_func<-function(homo,heter,noise){
consist.vars=c(seq(1:5),seq(106,110,by=1))
tf1=length(intersect(consist.vars,homo))/10
tf2=length(intersect(consist.vars,heter))/10
tf3=length(intersect(consist.vars,noise))/10
inconsist.vars=210+seq(1,60,by=2)
tf4=length(intersect(inconsist.vars,homo))/30
tf5=length(intersect(inconsist.vars,heter))/30
tf6=length(intersect(inconsist.vars,noise))/30
noise.vars=c(seq(6,105,by=1),seq(111,210,by=1),210+seq(2,60,by=2),seq(271,1400,by=1))
tf7=length(intersect(noise.vars,homo))/1360
tf8=length(intersect(noise.vars,heter))/1360
tf9=length(intersect(noise.vars,noise))/1360
t=c(tf1,tf2,tf3,tf4,tf5,tf6,tf7,tf8,tf9)
t_mat=matrix(t,ncol=3)
return(t(t_mat))
}
f<-function(Pred_type="SNP",K,nlower,nupper,sigma,level="e"){
library(gglasso)
library(glmnet)
library(tidyverse)
library(HDeconometrics)
library(stats)
mydata<-Data_Generator(Pred_type=Pred_type,K=K,level=level,sigma=sigma,nlower=nlower,nupper=nupper)
x=mydata[[1]]
y=mydata[[2]]
n=mydata[[3]]
sid=mydata[[4]]
#### grouped lasso
grouped<-group_lasso(x=x,y=y,sid=sid,wt=FALSE,solution_path=FALSE,y_name=NULL)
consistent.g=grouped[[1]]
inconsistent.g=grouped[[2]]
noise.g=grouped[[3]]
grouped_rate<-eval_func( homo=consistent.g,
heter=inconsistent.g,
noise=noise.g)
### grouped lasso with wt
grouped_wt<-group_lasso(x=x,y=y,sid=sid,wt=TRUE,solution_path=FALSE,y_name=NULL)
consistent.g=grouped_wt[[1]]
inconsistent.g=grouped_wt[[2]]
noise.g=grouped_wt[[3]]
grouped_wt_rate<-eval_func(homo=consistent.g,
heter=inconsistent.g,
noise=noise.g)
return(cbind(grouped_rate,grouped_wt_rate))
}
f(Pred_type="Con",K=4,nlower=50,nupper=300,sigma=4,level="e")
f(Pred_type="Con",K=4,nlower=50,nupper=300,sigma=4,level="e")
f(Pred_type="SNP",K=4,nlower=50,nupper=300,sigma=4,level="e")
f(Pred_type="SNP",K=4,nlower=50,nupper=300,sigma=4,level="e")
f(Pred_type="SNP",K=4,nlower=200,nupper=500,sigma=4,level="e")
f(Pred_type="SNP",K=4,nlower=50,nupper=300,sigma=4,level="e")
install.packages{utils}
install.packages("utils")
install.packages("utils")
install_github("Pei-Yang/HomUHet")
install_github(Pei-Yang/HomUHet,
auth_token = 6c306d53d56f1e8a2ce6601b9a83a234fa18e2e5, host = "https://api.github.com")
install_github(Pei-Yang/HomUHet,
auth_token = "6c306d53d56f1e8a2ce6601b9a83a234fa18e2e5", host = "https://api.github.com")
install_github(Pei-Yang/HomUHet,
auth_token = "6c306d53d56f1e8a2ce6601b9a83a234fa18e2e5")
install_github("Pei-Yang/HomUHet",
auth_token = "6c306d53d56f1e8a2ce6601b9a83a234fa18e2e5")
install.packages("HomUHet")
install.packages("HomUHet")
library(HomUHet)
Data_Generator<-function(Pred_type="Con", K,level,sigma,nlower,nupper){
library(MASS)
J=1400
v=c(1,rep(NA,(J-1)))
p=0.5
for (i in 2:J){
v[i]=p^(i-1)
}
Sigma=toeplitz(v)
t=0
x=rep(0,J)
y=0
sid=0
b=rep(0,40)
n=0
if (K==4){
if (level=="h"){
fixed.b=c(runif(5,1,3),runif(5,-3,-1))
b.matrix=matrix(0,ncol=30,nrow=K)
for (j in 1:30){
if (j<11){
b.matrix[,j]=sample(c(runif(2,1,1.5),runif(2,-1.5,-1)),K)
}
else {if (j<21){
b.matrix[,j]=sample(c(runif(1,1,1.5),runif(1,2,2.5),runif(2,3,3.5)),K)
}
else {
b.matrix[,j]=sample(c(runif(1,-1.5,-1),runif(1,-2.5,-2),runif(2,-3.5,-3)),K)
}
}
}
modified.b.matrix<-matrix(0,ncol=60,nrow=K)
for (j in 1:30){
modified.b.matrix[,(j*2-1)]=b.matrix[,j]
}
} else if (level=="m"){
fixed.b=c(runif(5,1,3),runif(5,-3,-1))
b.matrix=matrix(0,ncol=30,nrow=K)
for (j in 1:30){
if (j<11){
b.matrix[,j]=sample(c(runif(2,2,2.5),runif(2,-2.5,-2)),K)
}
else {if (j<21){
b.matrix[,j]=sample(c(runif(1,1,1.5),runif(1,3,3.5),runif(2,5,5.5)),K)
}
else {
b.matrix[,j]=sample(c(runif(1,-1.5,-1),runif(1,-3.5,-3),runif(2,-5.5,-5)),K)
}
}
}
modified.b.matrix<-matrix(0,ncol=60,nrow=K)
for (j in 1:30){
modified.b.matrix[,(j*2-1)]=b.matrix[,j]
}
} else {
fixed.b=c(runif(5,3,6),runif(5,-6,-3))
b.matrix=matrix(0,ncol=30,nrow=K)
for (j in 1:30){
if (j<11){
b.matrix[,j]=sample(c(runif(2,5,6.5),runif(2,-6.5,-5)),K)
}
else {if (j<21){
b.matrix[,j]=sample(c(runif(1,1,2),runif(1,5,6),runif(2,9,10)),K)
}
else {
b.matrix[,j]=sample(c(runif(1,-2,-1),runif(1,-6,-5),runif(2,-10,-9)),K)
}
}
}
modified.b.matrix<-matrix(0,ncol=60,nrow=K)
for (j in 1:30){
modified.b.matrix[,(j*2-1)]=b.matrix[,j]
}
}} else {
if (level=="h"){
fixed.b=c(runif(5,1,3),runif(5,-3,-1))
b.matrix=matrix(0,ncol=30,nrow=K)
for (j in 1:30){
if (j<11){
b.matrix[,j]=sample(c(runif(5,1,1.5),runif(5,-1.5,-1)),K)
}
else {if (j<21){
b.matrix[,j]=sample(c(runif(3,1,1.5),runif(3,2,2.5),runif(4,3,3.5)),K)
}
else {
b.matrix[,j]=sample(c(runif(3,-1.5,-1),runif(3,-2.5,-2),runif(4,-3.5,-3)),K)
}
}
}
modified.b.matrix<-matrix(0,ncol=60,nrow=K)
for (j in 1:30){
modified.b.matrix[,(j*2-1)]=b.matrix[,j]
}
} else if (level=="m"){
fixed.b=c(runif(5,1,3),runif(5,-3,-1))
b.matrix=matrix(0,ncol=30,nrow=K)
for (j in 1:30){
if (j<11){
b.matrix[,j]=sample(c(runif(5,2,2.5),runif(5,-2.5,-2)),K)
}
else {if (j<21){
b.matrix[,j]=sample(c(runif(3,1,1.5),runif(3,3,3.5),runif(4,5,5.5)),K)
}
else {
b.matrix[,j]=sample(c(runif(3,-1.5,-1),runif(3,-3.5,-3),runif(4,-5.5,-5)),K)
}
}
}
modified.b.matrix<-matrix(0,ncol=60,nrow=K)
for (j in 1:30){
modified.b.matrix[,(j*2-1)]=b.matrix[,j]
}
} else {
fixed.b=c(runif(5,1,6),runif(5,-6,-1))
b.matrix=matrix(0,ncol=30,nrow=K)
for (j in 1:30){
if (j<11){
b.matrix[,j]=sample(c(runif(5,5,6.5),runif(5,-6.5,-5)),K)
}
else {if (j<21){
b.matrix[,j]=sample(c(runif(3,1,2),runif(3,5,6),runif(4,9,10)),K)
}
else {
b.matrix[,j]=sample(c(runif(3,-2,-1),runif(3,-6,-5),runif(4,-10,-9)),K)
}
}
}
modified.b.matrix<-matrix(0,ncol=60,nrow=K)
for (j in 1:30){
modified.b.matrix[,(j*2-1)]=b.matrix[,j]
}
}
}
if (Pred_type=="Con"){
while (t<K){
n.temp=sample(seq(nlower,nupper),1)
n=c(n,n.temp)
sid.temp=rep(t+1,n.temp)
sid=c(sid,sid.temp)
temp.x=mvrnorm(n.temp,mu=rep(0,J),Sigma=Sigma)
temp.rb=c(fixed.b[1:5],rep(0,100),fixed.b[6:10],rep(0,100),modified.b.matrix[(t+1),])
temp.y=rnorm(1,0,5)+temp.x[,1:270]%*%temp.rb+rnorm(n.temp,0,sigma)
temp.y=temp.y
x=rbind(x,scale(temp.x))
y=c(y,temp.y)
t=t+1
}} else {
allele.freq=runif(J,0.05,0.5)
while (t<K){
n.temp=sample(seq(nlower,nupper),1)
n=c(n,n.temp)
sid.temp=rep(t+1,n.temp)
sid=c(sid,sid.temp)
divider=rep(0,J)
temp.x1=matrix(0,ncol=J,nrow=n.temp)
temp.x2=matrix(0,ncol=J,nrow=n.temp)
temp.z1=mvrnorm(n.temp,mu=rep(0,J),Sigma=Sigma)
temp.z2=mvrnorm(n.temp,mu=rep(0,J),Sigma=Sigma)
for (j in 1:J){
temp.x1[,j]=ifelse(temp.z1[,j]<=qnorm(allele.freq[j]),1,0)
temp.x2[,j]=ifelse(temp.z2[,j]<=qnorm(allele.freq[j]),1,0)
divider[j]=sqrt(allele.freq[j]*(1-allele.freq[j]))
}
temp.x=temp.x1+temp.x2
temp.rb=c(fixed.b[1:5],rep(0,100),fixed.b[6:10],rep(0,100),modified.b.matrix[(t+1),])/divider[1:270]
temp.y=rnorm(1,0,5)+temp.x[,1:270]%*%temp.rb+rnorm(n.temp,0,sigma)
temp.x=scale(temp.x)
temp.x[is.na(temp.x)]<-0
x=rbind(x,temp.x)
y=c(y,temp.y)
t=t+1
}
}
x=x[-1,]
y=y[-1]
n=n[-1]
sid=sid[-1]
return(list(x,y,n,sid))
}
mydata=Data_Generator(Pred_type="Con", K=4,level="e",sigma=4,nlower=50,nupper=300)
data_yx=cbind(mydata[[2]],mydata[[1]])
data_sid=mydata[[4]]
HomUHet(data=data_yx,sid=data_sid,solution_path=FALSE,y_name=NULL)
check()
check()
check()
document()
check()
document()
check()
document()
document()
check()
document()
document()
document()
document()
document()
check()
document()
check()
document()
check()
install_github("Pei-Yang/HomUHet",auth_token="6c306d53d56f1e8a2ce6601b9a83a234fa18e2e5")
version()
r.version()
Version()
version
