w_x=x*weight
w_y=y*weight
ini.beta<-cv.glmnet(as.matrix(w_x),w_y,alpha=0,standardize=FALSE)
bic.fit<-glmnet(as.matrix(w_x),w_y, penalty.factor=1/abs(coef(ini.beta,s="lambda.min")[-1]),standardize=FALSE)
step1.index=abs(bic.fit$beta)>0
step1.bic=rep(0,ncol(step1.index))
for(k in 1:length(step1.bic)){
temp.step1.data=as.data.frame(cbind(w_y,w_x[,step1.index[,k]]))
temp.step1.fit=lm(w_y~.,data=temp.step1.data)
temp.dev=-2*logLik(temp.step1.fit)
temp.df=sum(step1.index[,k])
step1.bic[k]=temp.dev+temp.df*log(length(w_y))
}
bic.step1.non.zero.beta=step1.index[,which.min(step1.bic)]
### subtraction
selected.data=as.data.frame(cbind(w_y,w_x[,bic.step1.non.zero.beta]))
beta.ls.fit<-lm(w_y~.,data=selected.data)
y.res=y-cbind(rep(1,length(y)),x[,step1.bic.non.zero.beta])%*%beta.ls.fit$coefficients
selected.data=as.data.frame(cbind(w_y,w_x[,bic.step1.non.zero.beta]))
beta.ls.fit<-lm(w_y~.,data=selected.data)
y.res=y-cbind(rep(1,length(y)),x[,bic.step1.non.zero.beta])%*%beta.ls.fit$coefficients
dim(selected.data)
length(which(step1.index[,1]==FALSE))
dim(selected.data)
bic.step1.non.zero.beta
length(which(step1.index[,1]==FALSE))
which(bic.step1.non.zero.beta==TRUE)
J=93
m=93*2/3
K=4
n=c(length(lumA_y),length(lumB_y),length(her2_y),length(basal_y))
x.by.var<-matrix(0,nrow=sum(n),ncol=J*K)
for (j in 1:J){
for (i in 1:K){
temp=x.by.var[,((j-1)*K+1):(j*K)]
if(i<2){
temp[1:n[i],i]=x[1:n[i],j]
}
else
temp[(sum(n[seq(1:(i-1))])+1):(sum(n[seq(1:(i))])),i]=x[(sum(n[seq(1:(i-1))])+1):(sum(n[seq(1:(i))])),j]
x.by.var[,((j-1)*K+1):(j*K)]=temp
}
}
##### group index
library(gglasso)
group=rep(0,J*K)
for (j in 1:J){
group[((j-1)*K+1):(j*K)]=rep(j,K)
}
#### obtaining preliminary fit for delta j
x.by.var=as.matrix(x.by.var)
y.res=as.vector(y.res)
ini.delta.fit<-cv.glmnet(as.matrix(x.by.var),y.res, alpha = 0, standardize = FALSE,intercept = TRUE)
ini.delta.fit<-glmnet(as.matrix(x.by.var),y.res, alpha = 0, standardize = FALSE,intercept = TRUE,lambda=ini.delta.fit$lambda.min)
ini.delta.norm=rep(0,J)
ini.delta=ini.delta.fit$beta
for (j in 1:J){
ini.delta.norm[j]=norm(ini.delta[((j-1)*K+1):(j*K)],type="2")
}
### separating data by subtypes
x1=x[1:n[1],]
y.res1=y.res[1:n[1]]
x2=x[(n[1]+1):(n[1]+n[2]),]
y.res2=y.res[(n[1]+1):(n[1]+n[2])]
x3=x[(n[1]+n[2]+1):(n[1]+n[2]+n[3]),]
y.res3=y.res[(n[1]+n[2]+1):(n[1]+n[2]+n[3])]
x4=x[(n[1]+n[2]+n[3]+1):(n[1]+n[2]+n[3]+n[4]),]
y.res4=y.res[(n[1]+n[2]+n[3]+1):(n[1]+n[2]+n[3]+n[4])]
#### ebic
third.term.grp<-function(x,J,K,gamma){
num.p=sum(x)/K
if (num.p==0){
factorial.part=0
}
else
factorial.part=sum(log(seq(1:J)))-(sum(log(seq(1:num.p)))+sum(log(seq(1:(J-num.p)))))
third.term=2*gamma*factorial.part
return(third.term)
}
library(stats)
index=abs(ebic.grp.fit$beta)>0
L=which.max(which(ebic.grp.fit$df<(42*4)))
ebic=rep(0,L)
for (l in 1:length(ebic)){
temp.third=third.term.grp(index[,l],J,K,1)
temp.select=unique(group[index[,l]])
if (l<2){
temp.data1=as.data.frame(y.res1)
temp.data2=as.data.frame(y.res2)
temp.data3=as.data.frame(y.res3)
temp.data4=as.data.frame(y.res4)
}
else{
temp.data1=as.data.frame(cbind(y.res1,x1[,temp.select]))
temp.data2=as.data.frame(cbind(y.res2,x2[,temp.select]))
temp.data3=as.data.frame(cbind(y.res3,x3[,temp.select]))
temp.data4=as.data.frame(cbind(y.res4,x4[,temp.select]))
}
temp.ls.fit1=lm(y.res1~.,data=temp.data1)
temp.ls.fit2=lm(y.res2~.,data=temp.data2)
temp.ls.fit3=lm(y.res3~.,data=temp.data3)
temp.ls.fit4=lm(y.res4~.,data=temp.data4)
temp.dev=-2*(logLik(temp.ls.fit1)+logLik(temp.ls.fit1)+logLik(temp.ls.fit1)+logLik(temp.ls.fit1))
temp.ls.coef=rbind(temp.ls.fit1$coefficients[-1],temp.ls.fit2$coefficients[-1],
temp.ls.fit3$coefficients[-1],temp.ls.fit4$coefficients[-1])
norm.lasso=rep(0,sum(index[,l])/K)
norm.ls=rep(0,sum(index[,l])/K)
if (sum(index[,l])/K>0){
for (i in 1:(sum(index[,l])/K)){
norm.lasso[i]=norm(ebic.grp.fit$beta[,l][index[,l]][((i-1)*K+1):(i*K)],type="2")
norm.ls[i]=norm(temp.ls.coef[,i],type="2")
}
temp.df=sum(index[,l])/K+(K-1)*sum(norm.lasso/norm.ls)
}
else
{temp.df=0}
ebic[l]=temp.dev+temp.df*log(length(y.res))+temp.third
}
ebic.grp.fit<-gglasso (as.matrix(x.by.var), y.res, group = group,
loss = "ls",
pf = rep(sqrt(K),J)/(ini.delta.norm+0.000000000001),
dfmax = 1400,
pmax = 1400,
eps = 1e-08, maxit = 3e+08,intercept=TRUE)
third.term.grp<-function(x,J,K,gamma){
num.p=sum(x)/K
if (num.p==0){
factorial.part=0
}
else
factorial.part=sum(log(seq(1:J)))-(sum(log(seq(1:num.p)))+sum(log(seq(1:(J-num.p)))))
third.term=2*gamma*factorial.part
return(third.term)
}
library(stats)
index=abs(ebic.grp.fit$beta)>0
L=which.max(which(ebic.grp.fit$df<(42*4)))
ebic=rep(0,L)
for (l in 1:length(ebic)){
temp.third=third.term.grp(index[,l],J,K,1)
temp.select=unique(group[index[,l]])
if (l<2){
temp.data1=as.data.frame(y.res1)
temp.data2=as.data.frame(y.res2)
temp.data3=as.data.frame(y.res3)
temp.data4=as.data.frame(y.res4)
}
else{
temp.data1=as.data.frame(cbind(y.res1,x1[,temp.select]))
temp.data2=as.data.frame(cbind(y.res2,x2[,temp.select]))
temp.data3=as.data.frame(cbind(y.res3,x3[,temp.select]))
temp.data4=as.data.frame(cbind(y.res4,x4[,temp.select]))
}
temp.ls.fit1=lm(y.res1~.,data=temp.data1)
temp.ls.fit2=lm(y.res2~.,data=temp.data2)
temp.ls.fit3=lm(y.res3~.,data=temp.data3)
temp.ls.fit4=lm(y.res4~.,data=temp.data4)
temp.dev=-2*(logLik(temp.ls.fit1)+logLik(temp.ls.fit1)+logLik(temp.ls.fit1)+logLik(temp.ls.fit1))
temp.ls.coef=rbind(temp.ls.fit1$coefficients[-1],temp.ls.fit2$coefficients[-1],
temp.ls.fit3$coefficients[-1],temp.ls.fit4$coefficients[-1])
norm.lasso=rep(0,sum(index[,l])/K)
norm.ls=rep(0,sum(index[,l])/K)
if (sum(index[,l])/K>0){
for (i in 1:(sum(index[,l])/K)){
norm.lasso[i]=norm(ebic.grp.fit$beta[,l][index[,l]][((i-1)*K+1):(i*K)],type="2")
norm.ls[i]=norm(temp.ls.coef[,i],type="2")
}
temp.df=sum(index[,l])/K+(K-1)*sum(norm.lasso/norm.ls)
}
else
{temp.df=0}
ebic[l]=temp.dev+temp.df*log(length(y.res))+temp.third
}
ebic.lambda=ebic.grp.fit$lambda[which.min(ebic)]
ebic.coef=ebic.grp.fit$beta[,which.min(ebic)]
ebic.fitted.delta=as.data.frame(cbind(as.factor(group),ebic.coef))
ebic.selection=ebic.fitted.delta%>%group_by(V1)%>%summarise_all(sd)
ebic.inconsistent=which(ebic.selection[,2]!=0)
intersect(ebic.inconsistent,inconsistent.vars)
ebic.inconsistent
c("age",names((lumA.data[,6:ncol(lumA.data)])[,ind]))[ebic.inconsistent]
### step 1 bic selection without weight
w_x=x
w_y=y
ini.beta<-cv.glmnet(as.matrix(w_x),w_y,alpha=0,standardize=FALSE)
bic.fit<-glmnet(as.matrix(w_x),w_y, penalty.factor=1/abs(coef(ini.beta,s="lambda.min")[-1]),standardize=FALSE)
step1.index=abs(bic.fit$beta)>0
step1.bic=rep(0,ncol(step1.index))
for(k in 1:length(step1.bic)){
temp.step1.data=as.data.frame(cbind(w_y,w_x[,step1.index[,k]]))
temp.step1.fit=lm(w_y~.,data=temp.step1.data)
temp.dev=-2*logLik(temp.step1.fit)
temp.df=sum(step1.index[,k])
step1.bic[k]=temp.dev+temp.df*log(length(w_y))
}
bic.step1.non.zero.beta=step1.index[,which.min(step1.bic)]
which(bic.step1.non.zero.beta==TRUE)
### subtraction
selected.data=as.data.frame(cbind(w_y,w_x[,bic.step1.non.zero.beta]))
beta.ls.fit<-lm(w_y~.,data=selected.data)
y.res=y-cbind(rep(1,length(y)),x[,bic.step1.non.zero.beta])%*%beta.ls.fit$coefficients
dim(selected.data)
### grouping by predictor
J=93
m=93*2/3
K=4
n=c(length(lumA_y),length(lumB_y),length(her2_y),length(basal_y))
x.by.var<-matrix(0,nrow=sum(n),ncol=J*K)
for (j in 1:J){
for (i in 1:K){
temp=x.by.var[,((j-1)*K+1):(j*K)]
if(i<2){
temp[1:n[i],i]=x[1:n[i],j]
}
else
temp[(sum(n[seq(1:(i-1))])+1):(sum(n[seq(1:(i))])),i]=x[(sum(n[seq(1:(i-1))])+1):(sum(n[seq(1:(i))])),j]
x.by.var[,((j-1)*K+1):(j*K)]=temp
}
}
##### group index
library(gglasso)
group=rep(0,J*K)
for (j in 1:J){
group[((j-1)*K+1):(j*K)]=rep(j,K)
}
#### obtaining preliminary fit for delta j
x.by.var=as.matrix(x.by.var)
y.res=as.vector(y.res)
ini.delta.fit<-cv.glmnet(as.matrix(x.by.var),y.res, alpha = 0, standardize = FALSE,intercept = TRUE)
ini.delta.fit<-glmnet(as.matrix(x.by.var),y.res, alpha = 0, standardize = FALSE,intercept = TRUE,lambda=ini.delta.fit$lambda.min)
ini.delta.norm=rep(0,J)
ini.delta=ini.delta.fit$beta
for (j in 1:J){
ini.delta.norm[j]=norm(ini.delta[((j-1)*K+1):(j*K)],type="2")
}
### separating data by subtypes
x1=x[1:n[1],]
y.res1=y.res[1:n[1]]
x2=x[(n[1]+1):(n[1]+n[2]),]
y.res2=y.res[(n[1]+1):(n[1]+n[2])]
x3=x[(n[1]+n[2]+1):(n[1]+n[2]+n[3]),]
y.res3=y.res[(n[1]+n[2]+1):(n[1]+n[2]+n[3])]
x4=x[(n[1]+n[2]+n[3]+1):(n[1]+n[2]+n[3]+n[4]),]
y.res4=y.res[(n[1]+n[2]+n[3]+1):(n[1]+n[2]+n[3]+n[4])]
#### ebic
ebic.grp.fit<-gglasso (as.matrix(x.by.var), y.res, group = group,
loss = "ls",
pf = rep(sqrt(K),J)/(ini.delta.norm+0.000000000001),
dfmax = 1400,
pmax = 1400,
eps = 1e-08, maxit = 3e+08,intercept=TRUE)
third.term.grp<-function(x,J,K,gamma){
num.p=sum(x)/K
if (num.p==0){
factorial.part=0
}
else
factorial.part=sum(log(seq(1:J)))-(sum(log(seq(1:num.p)))+sum(log(seq(1:(J-num.p)))))
third.term=2*gamma*factorial.part
return(third.term)
}
library(stats)
index=abs(ebic.grp.fit$beta)>0
L=which.max(which(ebic.grp.fit$df<(42*4)))
ebic=rep(0,L)
for (l in 1:length(ebic)){
temp.third=third.term.grp(index[,l],J,K,1)
temp.select=unique(group[index[,l]])
if (l<2){
temp.data1=as.data.frame(y.res1)
temp.data2=as.data.frame(y.res2)
temp.data3=as.data.frame(y.res3)
temp.data4=as.data.frame(y.res4)
}
else{
temp.data1=as.data.frame(cbind(y.res1,x1[,temp.select]))
temp.data2=as.data.frame(cbind(y.res2,x2[,temp.select]))
temp.data3=as.data.frame(cbind(y.res3,x3[,temp.select]))
temp.data4=as.data.frame(cbind(y.res4,x4[,temp.select]))
}
temp.ls.fit1=lm(y.res1~.,data=temp.data1)
temp.ls.fit2=lm(y.res2~.,data=temp.data2)
temp.ls.fit3=lm(y.res3~.,data=temp.data3)
temp.ls.fit4=lm(y.res4~.,data=temp.data4)
temp.dev=-2*(logLik(temp.ls.fit1)+logLik(temp.ls.fit1)+logLik(temp.ls.fit1)+logLik(temp.ls.fit1))
temp.ls.coef=rbind(temp.ls.fit1$coefficients[-1],temp.ls.fit2$coefficients[-1],
temp.ls.fit3$coefficients[-1],temp.ls.fit4$coefficients[-1])
norm.lasso=rep(0,sum(index[,l])/K)
norm.ls=rep(0,sum(index[,l])/K)
if (sum(index[,l])/K>0){
for (i in 1:(sum(index[,l])/K)){
norm.lasso[i]=norm(ebic.grp.fit$beta[,l][index[,l]][((i-1)*K+1):(i*K)],type="2")
norm.ls[i]=norm(temp.ls.coef[,i],type="2")
}
temp.df=sum(index[,l])/K+(K-1)*sum(norm.lasso/norm.ls)
}
else
{temp.df=0}
ebic[l]=temp.dev+temp.df*log(length(y.res))+temp.third
}
ebic.lambda=ebic.grp.fit$lambda[which.min(ebic)]
ebic.coef=ebic.grp.fit$beta[,which.min(ebic)]
ebic.fitted.delta=as.data.frame(cbind(as.factor(group),ebic.coef))
ebic.selection=ebic.fitted.delta%>%group_by(V1)%>%summarise_all(sd)
ebic.inconsistent=which(ebic.selection[,2]!=0)
inconsistent.vars=c(4,9,10,19,22,25,28,29,32,34,35,39,42,49,54,55,56,57,58,59,61,66,67,76,81,83,87,91)
intersect(ebic.inconsistent,inconsistent.vars)
c("age",names((lumA.data[,6:ncol(lumA.data)])[,ind]))[ebic.inconsistent]### names of genes picked by ebic
c("age",names((lumA.data[,6:ncol(lumA.data)])[,ind]))[intersect(ebic.inconsistent,inconsistent.vars)]### names of genes in the itersection of "inconsistent" picked by separte fitting and ebic
ebic.consistent=intersect(which(ebic.selection[,2]==0),which(bic.step1.non.zero.beta==TRUE))
ebic.consistent
ebic.inconsistent
ebic.consistent
c("age",names((lumA.data[,6:ncol(lumA.data)])[,ind]))[ebic.consistent]
c("age",names((lumA.data[,6:ncol(lumA.data)])[,ind]))[ebic.inconsistent]
library(httr)
library(jsonlite)
getBarcode <- function(uuid, legacy = TRUE){
# Get manifest using the API
uuid <- tolower(uuid)
baseURL <- ifelse(legacy,"https://gdc-api.nci.nih.gov/legacy/files/?","https://gdc-api.nci.nih.gov/files/?")
options.pretty <- "pretty=true"
options.expand <- "expand=cases.samples.portions.analytes.aliquots"
options.field <- "fields=cases.samples.portions.analytes.aliquots.submitter_id"
option.size <- paste0("size=",length(uuid))
option.format <- paste0("format=JSON")
options.filter <- paste0("filters=",
URLencode('{"op":"and","content":[{"op":"in","content":{"field":"files.file_id","value":['),
paste0('"',paste(uuid,collapse = '","')),
URLencode('"]}}]}'))
url <- paste0(baseURL,paste(options.pretty, options.expand,option.size,
options.filter, options.field,
option.format, sep = "&"))
json  <- tryCatch(
fromJSON(url, simplifyDataFrame = TRUE),
error = function(e) {
fromJSON(content(GET(url), as = "text", encoding = "UTF-8"), simplifyDataFrame = TRUE)
}
)
df <- stack(unlist(json$data$hits))
barcode <- df[grep("TCGA",df[,1]),1]
df <- data.frame(uuid = uuid, barcode = barcode)
return(df)
}
getBarcode("ffa5fff7-6301-4cd8-8e63-a4d8294d1b0e", legacy = TRUE)
uuid<-c("ffa5fff7-6301-4cd8-8e63-a4d8294d1b0e")
uuid <- tolower(uuid)
baseURL <- ifelse(legacy,"https://gdc-api.nci.nih.gov/legacy/files/?","https://gdc-api.nci.nih.gov/files/?")
legacy=T
baseURL <- ifelse(legacy,"https://gdc-api.nci.nih.gov/legacy/files/?","https://gdc-api.nci.nih.gov/files/?")
options.pretty <- "pretty=true"
options.expand <- "expand=cases.samples.portions.analytes.aliquots"
options.field <- "fields=cases.samples.portions.analytes.aliquots.submitter_id"
option.size <- paste0("size=",length(uuid))
option.format <- paste0("format=JSON")
options.filter <- paste0("filters=",
URLencode('{"op":"and","content":[{"op":"in","content":{"field":"files.file_id","value":['),
paste0('"',paste(uuid,collapse = '","')),
URLencode('"]}}]}'))
url <- paste0(baseURL,paste(options.pretty, options.expand,option.size,
options.filter, options.field,
option.format, sep = "&"))
json  <- tryCatch(
fromJSON(url, simplifyDataFrame = TRUE),
error = function(e) {
fromJSON(content(GET(url), as = "text", encoding = "UTF-8"), simplifyDataFrame = TRUE)
}
)
url
fromJSON(url, simplifyDataFrame = TRUE)
getBarcode("ffa5fff7-6301-4cd8-8e63-a4d8294d1b0e", legacy = F)
library(GenomicDataCommons)
library(magrittr)
TCGAtranslateID = function(file_ids, legacy = FALSE) {
info = files(legacy = legacy) %>%
filter( ~ file_id %in% file_ids) %>%
select('cases.samples.submitter_id') %>%
results_all()
# The mess of code below is to extract TCGA barcodes
# id_list will contain a list (one item for each file_id)
# of TCGA barcodes of the form 'TCGA-XX-YYYY-ZZZ'
id_list = lapply(info$cases,function(a) {
a[[1]][[1]][[1]]})
# so we can later expand to a data.frame of the right size
barcodes_per_file = sapply(id_list,length)
# And build the data.frame
return(data.frame(file_id = rep(ids(info),barcodes_per_file),
submitter_id = unlist(id_list)))
}
res = TCGAtranslateID("ffa5fff7-6301-4cd8-8e63-a4d8294d1b0e")
firebrowser_RNAseq<-read.delim(file="/Users/sephinapeiyang/Downloads/⁨gdac.broadinstitute.org_BRCA.Merge_rnaseq__illuminahiseq_rnaseq__unc_edu__Level_3__gene_expression__data.Level_3.2016012800.0.0 2⁩")
firebrowser_RNAseq<-read.delim(file="/Users/sephinapeiyang/Downloads/⁨gdac.broadinstitute.org_BRCA.Merge_rnaseq__illuminahiseq_rnaseq__unc_edu__Level_3__gene_expression__data.Level_3.2016012800.0.0 2BRCA.rnaseq__illuminahiseq_rnaseq__unc_edu__Level_3__gene_expression__data.data.txt/⁩ ⁩")
firebrowser_RNAseq<-read.delim(file="/Users/sephinapeiyang/Documents/Research_from_july/BRCA.rnaseq__illuminahiseq_rnaseq__unc_edu__Level_3__gene_expression__data.data.txt⁩ ⁩")
firebrowser_RNAseq<-read.delim(file="/Users/sephinapeiyang/Documents/Research_from_july/BRCA.rnaseq__illuminahiseq_rnaseq__unc_edu__Level_3__gene_expression__data.data.txt")
dim(firebrowser_RNAseq)
names(firebrowser_RNAseq)[1:10]
getBarcode <- function(uuid, #legacy = TRUE
){
# Get manifest using the API
uuid <- tolower(uuid)
#baseURL <- ifelse(legacy,"https://api.gdc.cancer.gov/legacy/files/?","https://api.gdc.cancer.gov/files/?")
#baseURL <- ifelse(legacy,"https://gdc-api.nci.nih.gov/legacy/files/?","https://gdc-api.nci.nih.gov/files/?")
baseURL<- "https://tcga-data.nci.nih.gov/uuid/uuidws/mapping/json/uuid/?"
options.pretty <- "pretty=true"
options.expand <- "expand=cases.samples.portions.analytes.aliquots"
options.field <- "fields=cases.samples.portions.analytes.aliquots.submitter_id"
option.size <- paste0("size=",length(uuid))
option.format <- paste0("format=JSON")
options.filter <- paste0("filters=",
URLencode('{"op":"and","content":[{"op":"in","content":{"field":"files.file_id","value":['),
paste0('"',paste(uuid,collapse = '","')),
URLencode('"]}}]}'))
url <- paste0(baseURL,paste(options.pretty, options.expand,option.size,
options.filter, options.field,
option.format, sep = "&"))
json  <- tryCatch(
fromJSON(url, simplifyDataFrame = TRUE),
error = function(e) {
fromJSON(content(GET(url), as = "text", encoding = "UTF-8"), simplifyDataFrame = TRUE)
}
)
df <- stack(unlist(json$data$hits))
barcode <- df[grep("TCGA",df[,1]),1]
df <- data.frame(uuid = uuid, barcode = barcode)
return(df)
}
getBarcode <- function(uuid #,legacy=True
){
# Get manifest using the API
uuid <- tolower(uuid)
#baseURL <- ifelse(legacy,"https://api.gdc.cancer.gov/legacy/files/?","https://api.gdc.cancer.gov/files/?")
#baseURL <- ifelse(legacy,"https://gdc-api.nci.nih.gov/legacy/files/?","https://gdc-api.nci.nih.gov/files/?")
baseURL<- "https://tcga-data.nci.nih.gov/uuid/uuidws/mapping/json/uuid/?"
options.pretty <- "pretty=true"
options.expand <- "expand=cases.samples.portions.analytes.aliquots"
options.field <- "fields=cases.samples.portions.analytes.aliquots.submitter_id"
option.size <- paste0("size=",length(uuid))
option.format <- paste0("format=JSON")
options.filter <- paste0("filters=",
URLencode('{"op":"and","content":[{"op":"in","content":{"field":"files.file_id","value":['),
paste0('"',paste(uuid,collapse = '","')),
URLencode('"]}}]}'))
url <- paste0(baseURL,paste(options.pretty, options.expand,option.size,
options.filter, options.field,
option.format, sep = "&"))
json  <- tryCatch(
fromJSON(url, simplifyDataFrame = TRUE),
error = function(e) {
fromJSON(content(GET(url), as = "text", encoding = "UTF-8"), simplifyDataFrame = TRUE)
}
)
df <- stack(unlist(json$data$hits))
barcode <- df[grep("TCGA",df[,1]),1]
df <- data.frame(uuid = uuid, barcode = barcode)
return(df)
}
getBarcode("ffa5fff7-6301-4cd8-8e63-a4d8294d1b0e")
uuid="ffa5fff7-6301-4cd8-8e63-a4d8294d1b0e"
uuid <- tolower(uuid)
baseURL<- "https://tcga-data.nci.nih.gov/uuid/uuidws/mapping/json/uuid/?"
url <- paste0(baseURL,uuid)
url
baseURL<- "https://tcga-data.nci.nih.gov/uuid/uuidws/mapping/json/uuid/"
url <- paste0(baseURL,uuid)
url
json  <- tryCatch(
fromJSON(url, simplifyDataFrame = TRUE),
error = function(e) {
fromJSON(content(GET(url), as = "text", encoding = "UTF-8"), simplifyDataFrame = TRUE)
}
)
fromJSON(url, simplifyDataFrame = TRUE)
uuid="30a1fe5e-5b12-472c-aa86-c2db8167ab23"
uuid <- tolower(uuid)
uuid
baseURL<- "https://tcga-data.nci.nih.gov/uuid/uuidws/mapping/json/uuid/"
url <- paste0(baseURL,uuid)
fromJSON(url, simplifyDataFrame = TRUE)
library(GenomicDataCommons)
library(magrittr)
file_uuids = files() %>% results(size=15) %>% ids()
head(file_uuids)
fromJSON(url)
install.packages("TCGAutils")
updateR()
install.packages("TCGAutils")
install.packages("devtools")
library(devtools)
install_github("waldronlab/TCGAutils")
71+17
install.packages("devtools")
setwd("/Users/sephinapeiyang/Documents/R packages/HomUHet")
library(usethis)
usethis::use_vignette("my-vignette")
devtools::install("HomUHet")
install_github("Pei-Yang/HomUHet")
library(devtools)
install_github("Pei-Yang/HomUHet")
devtools::install_github("Pei-Yang/HomUHet"
,auth_token = "6c306d53d56f1e8a2ce6601b9a83a234fa18e2e5"
)
build_vignettes(
pkg = "HomUHet",
dependencies = "VignetteBuilder",
clean = TRUE,
upgrade = "never",
quiet = TRUE,
install = TRUE,
keep_md = TRUE
)
document()
library(roxygen2)
